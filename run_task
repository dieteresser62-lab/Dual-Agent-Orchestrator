#!/usr/bin/env bash
set -euo pipefail

# Resolve the script location robustly, even when realpath is unavailable.
if command -v realpath >/dev/null 2>&1; then
  SCRIPT_PATH="$(realpath "$0")"
else
  case "$0" in
    /*) SCRIPT_PATH="$0" ;;
    *) SCRIPT_PATH="$(pwd)/$0" ;;
  esac
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd -P)"
TASK_FILE="task.md"
STATE_FILE=".orchestrator/state.json"
STATE_PHASE=""
EXTRA_ARGS=()
WATCH_MODE="no"
SKIP_GIT_CHECK_ENV="${RUN_TASK_SKIP_GIT_CHECK:-}"

# Forward help output directly to the Python CLI to keep behavior centralized.
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  exec python3 "$SCRIPT_DIR/src/orchestrator.py" --help
fi

# First positional argument is treated as task file for convenience.
if [[ $# -gt 0 && "${1:-}" != -* ]]; then
  TASK_FILE="$1"
  shift
fi

if [[ $# -gt 0 ]]; then
  EXTRA_ARGS=("$@")
fi

if [[ -n "$SKIP_GIT_CHECK_ENV" ]]; then
  case "${SKIP_GIT_CHECK_ENV,,}" in
    1|true|yes|on)
      HAS_SKIP_GIT_CHECK="no"
      for arg in "${EXTRA_ARGS[@]}"; do
        if [[ "$arg" == "--skip-git-check" ]]; then
          HAS_SKIP_GIT_CHECK="yes"
          break
        fi
      done
      if [[ "$HAS_SKIP_GIT_CHECK" == "no" ]]; then
        EXTRA_ARGS+=("--skip-git-check")
      fi
      ;;
  esac
fi

for arg in "${EXTRA_ARGS[@]}"; do
  if [[ "$arg" == "--watch" ]]; then
    # Watch mode has its own state lifecycle and should never auto-resume old runs.
    WATCH_MODE="yes"
    break
  fi
done

DETECTED_TEST_CMD=""
if [[ ${RUN_TASK_TEST_CMD+x} == x ]]; then
  # Explicit override (including empty string to force skip).
  DETECTED_TEST_CMD="${RUN_TASK_TEST_CMD}"
# Auto-detect a sensible test command in common project layouts.
elif [[ -f pyproject.toml ]] && grep -q '\[tool\.pytest\]' pyproject.toml; then
  DETECTED_TEST_CMD="python3 -m pytest tests/ -v"
elif [[ -f package.json ]] && python3 -c 'import json,sys
try:
    with open("package.json", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)
scripts = data.get("scripts", {})
sys.exit(0 if isinstance(scripts, dict) and "test" in scripts else 1)
'; then
  DETECTED_TEST_CMD="npm test"
elif [[ -f Makefile ]] && grep -Eq '^[[:space:]]*test:' Makefile; then
  DETECTED_TEST_CMD="make test"
fi

if [[ "$WATCH_MODE" == "yes" ]]; then
  # In watch mode, always start a fresh task-processing loop.
  exec python3 "$SCRIPT_DIR/src/orchestrator.py" \
    --allow-fallback-to-gemini \
    --test-command "$DETECTED_TEST_CMD" \
    --agent-live-stream \
    --agent-live-stream-mode compact \
    --agent-live-stream-channels stdout \
    --agent-output none \
    "${EXTRA_ARGS[@]}"
fi

if [[ -f "$STATE_FILE" ]]; then
  # Read only the minimal phase field to decide resume-vs-new behavior.
  STATE_PHASE="$(python3 -c 'import json,sys
try:
    with open(sys.argv[1], encoding="utf-8") as f:
        data = json.load(f)
    print(str(data.get("phase", "")).strip())
except Exception:
    print("")
' "$STATE_FILE")"
fi

if [[ -f "$STATE_FILE" && "$STATE_PHASE" != "done" ]]; then
  # Resume in-progress work to preserve cycle history and checkpoints.
  echo "[INFO] Existing state found at $STATE_FILE -> resuming current run."
  FROZEN_STATUS="$(python3 -c 'import json,sys
try:
    with open(sys.argv[1], encoding="utf-8") as f:
        data = json.load(f)
    p1 = str((data.get("phase1") or {}).get("status", "")).strip().lower()
    p2 = str((data.get("phase2") or {}).get("status", "")).strip().lower()
    print("yes" if p1 == "frozen" or p2 == "frozen" else "no")
except Exception:
    print("no")
' "$STATE_FILE")"
  if [[ "$FROZEN_STATUS" == "yes" ]]; then
    # Frozen runs indicate prior quota/rate-limit interruptions.
    echo "[WARN] Previous run was frozen due to API quota. Make sure your quota has been reset before continuing."
  fi
  exec python3 "$SCRIPT_DIR/src/orchestrator.py" \
    --resume \
    --allow-fallback-to-gemini \
    --test-command "$DETECTED_TEST_CMD" \
    --agent-live-stream \
    --agent-live-stream-mode compact \
    --agent-live-stream-channels stdout \
    --agent-output none \
    --task-file "$TASK_FILE" \
    "${EXTRA_ARGS[@]}"
else
  if [[ -f "$STATE_FILE" && "$STATE_PHASE" == "done" ]]; then
    # A completed run should not be resumed; start a clean state instead.
    echo "[INFO] Existing state is completed (phase=done) -> starting new run."
  fi
  exec python3 "$SCRIPT_DIR/src/orchestrator.py" \
    --force-overwrite-state \
    --allow-fallback-to-gemini \
    --test-command "$DETECTED_TEST_CMD" \
    --agent-live-stream \
    --agent-live-stream-mode compact \
    --agent-live-stream-channels stdout \
    --agent-output none \
    --task-file "$TASK_FILE" \
    "${EXTRA_ARGS[@]}"
fi
